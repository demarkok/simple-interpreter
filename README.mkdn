# A parser and interpreter for a fictional programming language

## Syntax
```
FILE = BLOCK
BLOCK = (STATEMENT)*
BLOCK_WITH_BRACES = "{" BLOCK "}"
STATEMENT = FUNCTION | VARIABLE | EXPRESSION | WHILE | IF | ASSIGNMENT | RETURN | PRINTLN | READ
FUNCTION = "fun" IDENTIFIER "(" PARAMETER_NAMES ")" BLOCK_WITH_BRACES
VARIABLE = "var" IDENTIFIER ("=" EXPRESSION)?
PARAMETER_NAMES = IDENTIFIER{,}
WHILE = "while" "(" EXPRESSION ")" BLOCK_WITH_BRACES
IF = "if" "(" EXPRESSION ")" BLOCK_WITH_BRACES ("else" BLOCK_WITH_BRACES)?
ASSIGNMENT = IDENTIFIER "=" EXPRESSION
RETURN = "return" EXPRESSION
PRINTLN = "println" "(" ARGUMENTS ")"
READ = "read" "(" IDENTIFIER ")"
EXPRESSION = FUNCTION_CALL | BINARY_EXPRESSION | IDENTIFIER | LITERAL | "(" EXPRESSION ")"
FUNCTION_CALL = IDENTIFIER "(" ARGUMENTS ")"
ARGUMENTS = EXPRESSION{","}
BINARY_EXPRESSION = EXPRESSION OPERATOR EXPRESSION
OPERATOR =  "+" | "-" | "*" | "/" | "%" | ">" | "<" | ">=" | "<=" | "==" | "!=" | "||" | "&&"
IDENTIFIER = <like in C>
LITERAL = <like decimal literal in Java>

```

### Contractions:
```
X{Y} – possibly empty list of X's separeted by Y's
(X)* – X repeated 0 or more times
(X)? – optional X entrance
```

## Semantics
- Должны быть поддержаны однострочные комментарии, как в языке Си (`//`).
- Функции становятся доступны сразу после объявления, причем только внутри блока, где они объявлены.
- Перегрузки функций (с одинаковыми именами) не поддерживаются.
- Функция/переменная, объявленная во вложенном блоке переопределяет более внешнюю декларацию с таким же именем.
- При использовании неопределенной переменной/функции программа должна завершаться с ошибкой.
- В интерпретаторе должна быть определена встроенная функция `println` с произвольным количеством аргументов.
  Аргументы выводятся на новой строке через пробел.
- Если функция завершается без оператора return, считается что возвращаемое значение – 0.
- Все остальное определяется исходя из здравого смысла :)

## Examples
```
var a = 10
var b = 20
if (a > b) {
    println(1)
} else {
    println(0)
}
```

```
fun fib(n) {
    if (n <= 1) {
        return 1
    }
    return fib(n - 1) + fib(n - 2)
}

var i = 1
while (i <= 5) {
    println(i, fib(i))
    i = i + 1
}
```

```
fun foo(n) {
    fun bar(m) {
        return m + n
    }

    return bar(1)
}

println(foo(41)) // prints 42
```

## Требования к реализации
- Функция `main` должна интерпретировать файл, имя которого передано в первом аргументе.
- Можно использовать генераторы парсеров (см. ветку `antlr-example`).
- Если вы реализуете разбор вручную, то он должен состоять из двух частей: лексер и парсер.
- В случае наличия во входных данных синтаксической ошибки, интерпретатор должен
выдать номер строки, где что-то пошло не так.
- Вместе с решением должны быть предоставлены unit-тесты. Ожидаются три вида отдельных тестов:
    - Парсинг
    - Интерпретация готового дерева
    - Простые на "связку" первых двух компонентов
- По возможности исходный код не должен содержать предупреждений IDE и в целом
должен соответствовать требованиям, о которых шла речь на второй лекции.
